{{ capture output -}}
{{- ClientName = "MediatRSample"}}
//--------------------------------------------------------------------------------------------------
// <date>{{Date.Now}}</date>
// <auto-generated>
//    This code was generated from a template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// <auto-generated>
//--------------------------------------------------------------------------------------------------

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Diagnostics;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace Fsma.{{ClientName}}.Gateway;

{{- requests = data.Classes | Custom.MediatorRequests }}
{{- dtos = requests | Custom.AllReferencedTypes }}


public interface I{{ClientName}}Client
{
    {{- for service in requests | Custom.MediatorRequestsByService  }}
    I{{service.Key}}Client {{service.Key}} { get; }
    {{- end}}
}

{{ for service in requests | Custom.MediatorRequestsByService  }}
public interface I{{service.Key}}Client 
{        
    {{- for operation in service }}
    Task<{{operation.Response}}> {{operation.Request.BareName}}Async({{operation.Request}} request);
    {{operation.Response}} {{operation.Request.BareName}}({{operation.Request}} request);
    {{- end }}        
}
{{ end }}

{{- for enum in dtos | Custom.IsEnum }}
public enum {{enum.Name}} 
{
{{- for value in enum.Values}}
    {{value.Name}} = {{value.Value}},
{{-end}}
}
{{end}}

    
{{- for class in dtos | Custom.IsClass }}
public partial class {{class.Name}} {{ class | Custom.ClassBase }}
{   
    {{class | Custom.IsFileRequest ? "public List<File> Files { get; set; } = new List<File>();" : ""}}

    {{- for property in class.Properties | Symbols.ThatArePublic | Symbols.ThatDoNotHaveAttribute("JsonIgnore") }}
    public {{property.Type}} {{ property.Name }} { get; set; }
    {{- end }}
}
{{ end }}


{{- for service in requests | Custom.MediatorRequestsByService  }}
[DebuggerStepThrough]
internal class {{service.Key}}Client(JsonRpcClient jsonRpcClient) : I{{service.Key}}Client 
{        
    {{- for operation in service }}
    public async Task<{{operation.Response}}> {{operation.Request.BareName}}Async({{operation.Request.BareName}} request) => await jsonRpcClient.SendAsync<{{operation.Response}}>("{{operation.Name}}", request);
    public {{operation.Response}} {{operation.Request.BareName}}({{operation.Request.BareName}} request) => jsonRpcClient.Send<{{operation.Response}}>("{{operation.Name}}", request);
    {{- end }}    
}
{{ end }}

[DebuggerStepThrough]
public class {{ClientName}}Client : I{{ClientName}}Client {

    private readonly JsonRpcClient _jsonRpcClient;

    {{- for service in requests | Custom.MediatorRequestsByService  }}
    public I{{service.Key}}Client {{service.Key}} { get; }
    {{- end }}

    public {{ClientName}}Client(System.Net.Http.HttpClient httpClient)
    {
        _jsonRpcClient = new JsonRpcClient(httpClient);
        {{~ for service in requests | Custom.MediatorRequestsByService  }}
        {{service.Key}} = new {{service.Key}}Client(_jsonRpcClient);
        {{- end }}
    }
}

public readonly struct Unit : IEquatable<Unit>, IComparable<Unit>, IComparable
{
    private static readonly Unit _value = new();    
    public static ref readonly Unit Value => ref _value;    
    public static Task<Unit> Task { get; } = System.Threading.Tasks.Task.FromResult(_value);    
    public int CompareTo(Unit other) => 0;    
    int IComparable.CompareTo(object? obj) => 0;    
    public override int GetHashCode() => 0;    
    public bool Equals(Unit other) => true;    
    public override bool Equals(object? obj) => obj is Unit;    
    public static bool operator ==(Unit first, Unit second) => true;    
    public static bool operator !=(Unit first, Unit second) => false;    
    public override string ToString() => "()";
}

public interface IFileRequest 
{
    List<File> Files { get; }
}

public class File
{
    public string Filename { get; set; }
    public HttpContent HttpContent { get; set; }
    
    public File()
    {
    }

    public File(string filename, HttpContent content)
    {
        Filename = filename;
        HttpContent = content;        
    }

    public File(string filename, string contentType, byte[] data)
    {
        var content = new StreamContent(new System.IO.MemoryStream(data));
        content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(contentType);

        Filename = filename;
        HttpContent = content;        
    }  
}

internal class JsonRpcClient
{
    private readonly System.Net.Http.HttpClient _httpClient;

    public JsonRpcClient(System.Net.Http.HttpClient httpClient)
    {
        _httpClient = httpClient;
        _httpClient.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));
    }

    internal static HttpContent CreateContent(string methodName, object request)
    {
        var jsonRpcRequest = new
        {
            id = Guid.NewGuid().ToString(),
            jsonRpc = "2.0",
            method = methodName,
            @params = request
        };

        var payload = JObject.FromObject(jsonRpcRequest).ToString();
        
        if (request is IFileRequest fileRequest)
        {
            var multipartContent = new MultipartFormDataContent("mydata");
            multipartContent.Add(new StringContent(payload, Encoding.UTF8, "application/json"), "jsonrpc");

            foreach (var file in fileRequest.Files)
            {
                multipartContent.Add(file.HttpContent, "files", file.Filename);
            }

            return multipartContent;
        }
        else
        {
            return new StringContent(payload, Encoding.UTF8, "application/json");
        }
    }

    public T Send<T>(string methodName, object request)
    {
        var content = CreateContent(methodName, request);       
        var response = _httpClient.PostAsync("jsonrpc", content).GetAwaiter().GetResult();
        var jsonResponse = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
        var jsonRpcResponse = JsonConvert.DeserializeObject<JsonRpcResponse<T>>(jsonResponse);
        return jsonRpcResponse.Result;
    }

    public async Task<T> SendAsync<T>(string methodName, object request)
    {
        var content = CreateContent(methodName, request);
        var response = await _httpClient.PostAsync("jsonrpc", content); 
        var jsonResponse = await response.Content.ReadAsStringAsync();
        var jsonRpcResponse = JsonConvert.DeserializeObject<JsonRpcResponse<T>>(jsonResponse);
        return jsonRpcResponse.Result;
    }
}

[JsonObject]
internal class JsonRpcResponse<T>
{
    [JsonProperty("id")]
    public string Id { get; set; }

    [JsonProperty("jsonrpc")]
    public string JsonRpcVersion { get; private set; } = "2.0";

    [JsonProperty("result")]
    public T Result { get; set; }

    [JsonProperty("error", NullValueHandling = NullValueHandling.Ignore)]
    public JsonRpcError Error { get; set; }
}

internal class JsonRpcError
{
    [JsonProperty("code", Required = Required.Always)]
    public int Code { get; set; }

    [JsonProperty("message", Required = Required.Always)]
    public string Message { get; set; }

    [JsonProperty("data")]
    public object Data { get; set; }
}

{{ end }}
{{ filePath = "./Clients/" | String.Append ClientName | String.Append "Client.g.cs" }}
{{ Save output filePath }}
